"""
Синхронизация процессов через очередь JoinableQueue
"""

import time
import multiprocessing


def consumer(input_q):
    """Потребитель"""
    while True:
        print('извлекаю')
        # извлечь элемент из очереди
        item = input_q.get()
        # Обработать элемент
        # Здесь может быть некоторая обработка элемента
        print(item)
        # Сообщить о завершении обработки
        # task_done - используется потребителем, чтобы сообщить,
        # что элемент очереди, полученный методом q.get(), был обработан
        input_q.task_done()
        time.sleep(1)


def producer(sequence_obj, output_q):
    """функция, в которой производитель добавляет элементы в очередь"""
    for item in sequence_obj:
        # Добавить элемент в очередь
        print('помещаю')
        output_q.put(item)
        time.sleep(1)


# Настройка
if __name__ == '__main__':
    # создает необособленный процесс очереди, доступной для совместного использования.Очереди
    # этого типа похожи на Queue, но позволяют потребителю известить поставщика, что
    # элементы были благополучно обработаны.
    QUEUE = multiprocessing.JoinableQueue()
    # Создать процесс-потребитель
    CONS_P = multiprocessing.Process(target=consumer, args=(QUEUE,))
    CONS_P.daemon = True
    # запустить процесс-потребитель
    CONS_P.start()

    # Воспроизвести элементы.
    # Переменная sequence представляет последовательность элементов, которые
    # будут передаваться потребителю. На практике вместо переменной можно
    # использовать генератор или воспроизводить элементы каким-либо другим
    # способом.
    # sequence - некоторые элементы-которые по очереди получает потребитель для обработки
    SEQUENCE = [1, 2, 3, 4]
    # запуск ф-ции производителя
    producer(SEQUENCE, QUEUE)

    # Дождаться, пока все элементы не будут обработаны
    # если забыть его вызвать, процесс-потребитель будет завершен еще до того,
    # как успеет обработать все элементы в очереди
    QUEUE.join()
